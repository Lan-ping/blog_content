## 引言

**生成对抗网络 GAN**是两个参与者的游戏，即生成器和判别器，它们广泛应用于合成高质量数据。 对于图像合成，生成器将潜在向量作为输入，并有望生成高质量的合成图像，而鉴别器则有望有效地将它们与真实图像区分开来。

**条件生成对抗网络 CGAN**能够通过将条件嵌入到生成器和判别器的输入中来生成语义图像。CGAN 中的各种条件包括标签、文本和图像，其中标签是最常见的一种。

**灾难性遗忘**：智能体在实践中获得所有训练数据并学习一次是不现实的，我们期望智能体像人类一样获得知识，即在生活中不断学习，快速有效地学习新任务，而不会忘记过去学到的知识。 要实现通用人工智能，需要赋予智能体持续学习的能力。 然而，实验表明，现在深度神经网络在学习新任务（称为灾难性遗忘）时保留先前学习任务中获得的知识仍然具有挑战性。

GAN 也严重遭受灾难性遗忘的困扰。 例如，在顺序任务训练中，生成器只能为最后一个任务生成令人满意的图像，而忘记了其他先前任务所拥有的能力。

近年来，研究人员为减轻灾难性遗忘做出了一些努力。 例如，**概念辅助反向传播** (CAB) 方法和**正交权重修改** (OWM) 方法已被提出并以一种新的方式来解决这个问题，以进行持续学习。 具体来说，在每一层网络中都构造了一个正交投影矩阵来保存学习到的知识，在学习一个新任务的过程中，神经网络中的梯度通过正交投影矩阵投影到所有先前学习到的特征的正交方向上。更新后的权重不仅可以适应新任务，还可以保留编码旧知识的有效性。

然而，对于 CGAN，生成器的输入是从除标签条件之外的相同分布中独立采样的随机噪声，它实际上会导致未学习任务的可用内存空间消失。

受 OWM 算法的启发，论文作者提出了一种新的 CGAN，称为**梯度正交投影 GAN**（GopGAN），以持续学习的方式生成合成数据，并将其应用于图像的顺序学习任务合成。

本文的主要贡献总结如下：

1. 给出了严格的数学证明，表明在特征空间的正交子空间中更新权重可以保证新任务的学习不会导致忘记旧任务中获得的知识。
2. 通过定义和求解一个优化问题，推导出一个新的投影矩阵的最优解。此外，提出了一种用于持续学习的迭代算法，这样在学习过去的任务中训练样本的特征就不需要为了学习新的任务而存储。
3. 对于 GAN，作者发现生成器的噪声输入来自相同的分布，并且为所有类别共享，这使得计算的投影矩阵容易接近零矩阵，很少有内存空间可用于新任务。为了解决这个问题，作者提出了一个新的任务相关的潜在向量，使每个任务具有不同的潜在向量，从而为新任务获得足够的内存空间。

## 相关工作

近年来，生成对抗网络（GAN）在图像生成方面已经显示出其有效性。 然而，如果没有监督条件，生成图像的类别是不可预测的。 Mirza 和 Osindero 提出了一种条件生成对抗网络（CGAN）来生成带有条件的语义图像。论文作者采用带有标签条件的 CGAN 作为本文的基本网络架构。

持续学习旨在赋予智能体学习序列任务的能力，而不会忘记在先前任务中获得的知识。近年来已经见证了一些努力，其中大部分集中在模型学习中权重梯度的修改。Kirkpatrick 等人提出了一种称为弹性权重合并 (EWC) 的方法，该方法在新任务和旧任务之间引入了权重约束。然而，在序列任务训练中，带有 EWC 的网络会为每个学习任务保留一个 Fisher 矩阵，Fisher 正则化器的积累会过度约束网络参数，导致新任务的学习障碍。施瓦茨等人。Schwarz 等人提出了一种改进的 EWC，称为 Online EWC，可扩展到大量任务。与 Online EWC 类似，Chaudhry 等人提出了 EWC++，在更新 Fisher 矩阵方面与 Online EWC 略有不同。开创性的工作 CAB 和 OWM 是反向传播算法的变体，并已成功应用于分类任务，但论文作者发现没有将这两种方法应用于 GAN 的工作。 **CAB 和 OWM 是两种类似的解决灾难性遗忘的方法，通过沿学习任务特征空间的正交方向更新网络权重。** CAB 和 OWM 的区别在于投影矩阵的设计。 CAB 基于 Conceptor 构造投影矩阵，OWM 基于递归最小二乘（RLS）算法。与 CAB 和 OWM 不同，本文作者重新定义了正交投影矩阵的形式并将其应用于 GAN。

GAN 在持续学习中也会遭受灾难性遗忘。Seff 等人将 EWC 应用于 GAN，这在一定程度上提高了生成图像的质量。Wu 等人提出了基于**记忆重放机制**的记忆重放 GAN（MeRGAN），以减轻对先前类别的遗忘。在 MeRGAN 中，提出了两种方法，即重放联合训练 (MeRGAN-JTR) 和重放对齐 (MeRGAN-RA)。但是，它们都需要大量的内存空间来重播旧任务，这将占用大量的网络训练空间和时间。基于 MeRGANs，Rios 等人提出了一种**累积闭环记忆重放** GAN（CloGAN），它通过设置每个旧任务的集群来减少记忆空间。与 MeRGAN 相比，CloGAN 节省了大量内存空间，但略微降低了生成图像的质量。<u>本质上，MeRGANs 和 CloGAN 是对旧任务进行再训练的方法，不保留所学知识，这是与本文方法的最大区别。</u> 本文所提出的 GopGAN 可以保留学习到的知识，并且不需要重播旧任务。Zhai 等人提出 LifelongGAN 使用**知识蒸馏**的方法将从之前的网络中学到的知识转移到新的网络中。<u>虽然知识蒸馏可以使新网络在一定程度上继承前一个网络所学的知识，但会破坏当前网络对前一个任务的响应。根据持续学习的约束规则，该方法不能利用之前的任务数据进行知识蒸馏，导致网络在学习新任务后对之前的任务数据的响应出现偏差。</u> Ye 等人提出了一个终生的 VAEGAN 来诱导强大的**生成重放网络**来学习有意义的潜在表示，从而有利于表示学习。他们还将生成重放网络应用于无监督、半监督和监督学习，并取得了很好的效果。<u>本文作者给出了严格的理论证明，证明作者的方法可以保持新网络对学习任务的输入响应不变，从而消除了灾难性遗忘问题，这也被大量实验证明。</u>

## 梯度正交投影生成对抗网络 GopGAN

### GAN 的持续学习设置

GopGAN 使用 CGAN 作为基础网络架构来生成语义图像。CGAN 由生成器 $G$ 和鉴别器 $D$ 组成。生成器 $G$ 以潜在向量 $z$ 和标签条件 $c$ 作为输入来生成假图像 $\widetilde{I}$，即 $\widetilde I = G(z|c)$，其中 $z$ 是从随机高斯采样 噪声分布，$c$ 是持续学习中每个特定任务的固定 one-hot 向量。 判别器 $D$ 接收条件向量 $c$ 和由 $G$ 生成的真实训练图像 $I$ 或假图像 $\widetilde{I}$ 并输出一个概率标量来表明输入图像是真还是假。 CGAN 网络的优化目标函数可以表示为:

$$
\tag{1}
\underset{G}{\min}\;\underset{D}{\max}\;V(D,G)=\mathbb{E}_{I\sim p_{data}}[\log D(I|c)]+\mathbb{E}_{z\sim p_{z}}[\log (1-D(G(z|c)))]
$$

其中，$p_{data}$ 和 $p_z$ 分别表示真实数据和潜在向量的分布。

当论文作者应用 GAN 生成多类别假数据时，可以将其建模为序列任务或持续学习的学习问题。在持续学习中，学习顺序可以是任意的。为简化起见，假设我们有 $M$ 个学习任务，它们用 $T_i$ 表示，$i = 1, 2, ... , M$, 其中 $i$ 正好对应于学习顺序。每个任务对应一个类别，因此其训练数据 $D_i$ 具有相同的标签 $c_i$。 只有当任务 $T_i$ 完全完成后，任务 $T_{i+1}$ 才能开始训练，同时我们期望学习任务中的训练数据 $\cup_{k=1}^{i}$ 对任务 $T_{i+1}$ 是不可用的。

### 梯度正交投影

在序列任务学习中，我们假设 GAN 已经完成了学习任务 $T_1, T_2,..., T_{i-1}$ 并且现在才开始学习任务 $T_i$。它的生成器由 $L$ 层组成。来自学习任务数据集的第 $l$ 层示例的输入特征 $\mathfrak{D}_{i-1}=\cup_{k=1}^{i-1}D_{k}$ 被收集到矩阵 $A_{l}=[x_{l}^{1}, x_{l}^{2},..., x_{l}^{N_{i-1}}]$，其中长度为 $d_l$ 的列向量 $x_{l}^{j}$ 表示第 $j$ 个示例，$N_{i-1}$ 表示 $\mathfrak{D}_ {i-1}$ 中的示例数。相应地，例如 $x_{l}^{j}$，第 $l$ 层的输出特征可以计算为 $x_{l+1}^{j} = \sigma (W_{l,i-1}^{\intercal}x_{l}^{j})$，其中 $W_{l,i-1}^{\intercal}$ 是权重矩阵 $W_{l,i-1}$ 的转置完成任务 $T_{i-1}$ 后的第 $l$ 层，$\sigma(\cdot)$ 表示非线性激活函数。在 GAN 中，非线性激活函数 $\sigma(\cdot)$ 通常采用 LeakyRelu 或其他基于 ReLu 的函数。需要注意的是，$x_{l+1}^{j}$ 也是第 $l+1$ 层的输入特征。特别地，当 $l = 1$ 时，第一层的输入是通过将潜在向量 $z^j$ 与标签条件向量 $c^j$ 拼接得到的，即 $x_1^j = z^j \oplus c^j$，其中 $\oplus$ 表示拼接操作。

在常规训练中，我们有 $A_{l+1}= \sigma (W_{l,i-1}^{\intercal}A_l)$。 这里，权重矩阵 $W_{l,i-1}$ 作为训练任务 $T_i$ 时的初始权重，即 $W_{l,i}(0)\overset{\triangle }{=}W_{l,i-1}$，其中 $W_{l,i-1}$ 表示最后一个任务 $T_{i-1}$ 的学习结果。 因此，$A_{l+1}= \sigma (W_{l,i}(0)^{\intercal}A_l)$。 步骤 $t$ 的权重更新为:

$$
\begin{aligned}
W_{l,i}(t) &= W_{l,i}(t-1) - \lambda_{i}\Delta W_{l,i}(t) \\
           &= W_{l,i}(0) - \lambda_{i}\sum_{k=1}^{t}\Delta W_{l,i}(k)
\tag{2}
\end{aligned}
$$

其中 $\lambda_{i}$ 是任务 $T_i$ 的学习率，$\Delta W_{l,i}(t)$ 表示在步骤 $t$ 通过某种方法（例如随机梯度下降法）计算的权重梯度。 在对任务 $T_i$ 进行 $t$ 步学习后，我们有权重矩阵 $W_{l,i}(t)$ 和新特征 ${A}'_{l+1}$ 可以通过下式计算:

$$
\begin{aligned}
{A}'_{l+1} &= \sigma (W_{l,i}^{\intercal}(t)A_{l}) \\
           &=\sigma(W_{l,i}^{\intercal}(0)A_{l}-\lambda_{i}\sum_{k=1}^{t}\Delta W_{l,i}^{\intercal}(k)A_{l})
\tag{3}
\end{aligned}
$$

新任务的不可预测的输入将使权重的更新不可控。几乎不可能满足方程 $\sum _{k=1}^{t} \Delta W_{l,i}^{\intercal}(k)A_{l} = \mathbf{0}$，其中 $\mathbf{0}$ 表示零矩阵。 因此，${A}'_{l+1}$ 几乎不等于$A_{l+1}$。${A}'_{l+1}\neq A_{l+1}$ 意味着网络忘记了从旧任务中学习的表示，并且它对旧任务输入示例的响应是不可预测和不可控的。

在提出的 GopGAN 中，为了避免生成器 $G$ 忘记先前任务的特征 $A_l$，$l=1, 2, ..., L$，我们为每一层构造一个大小为 $d_l \times d_l$ 的梯度正交投影矩阵 $P_l$，并让非零矩阵 $P_l$ 满足 $P_lA_l = \mathbf{0}$。在学习新任务期间，权重的更新通过修改后的梯度 $P_l^{\intercal}\Delta W_{l,i}(t)$ 进行代替梯度 $\Delta W_{l,i}(t)$，可以保证 ${A}'_{l+1}= A_{l+1}$ 在数学上始终成立，即在学习新任务时不会忘记从旧任务中学到的表示 . 数学证明如下：

$$
\begin{aligned}
{A}'_{l+1} &= \sigma (W_{l,i}^{\intercal}(t)A_{l}) \\ 
           &= \sigma ((W_{l,i}(0)-\lambda_{i}\sum_{k=1}^{t}P_{l}^{\intercal}\Delta W_{l,i}(k))^{\intercal}A_{l}) \\
           &=  \sigma (W_{l,i}(0)^{\intercal}A_{l}-\lambda_{i}\sum_{k=1}^{t}\Delta W_{l,i}^{\intercal}(k)P_{l}A_{l}) \\
           &= \sigma (W_{l,i}^{\intercal}(0)A_{l}) \\
           &= A_{l+1}\tag{4}
\end{aligned}
$$

等式（4）表明，在学习新任务的任何时刻 $t$，无论执行什么权重更新，如果我们能找到一个非零矩阵 $P_l$，则每一层对旧任务示例的网络响应保持不变，它满足 $P_l A_l = \mathbf{0}$。

为了找到这样一个矩阵 $P_l$ ，我们将其公式化为一个优化问题，目标函数定义为:

$$
\tag{5}
P_l=\arg \underset{P}{\min} (||PA_l||_{F}^2+\alpha ||P-\mathbf{I}||_{F}^2)
$$

其中 $||·||_F$表示矩阵的 Frobenius 范数，$\mathbf{I}$ 是单位矩阵，$\alpha$ 是反映 $A_l$对噪声容忍度的超参数。 当 $\alpha = 0$ 时，解 $P_l$ 的行空间与 $A_l$ 的列向量跨越的空间正交，这意味着对于 $A_l$ 中的每个列向量 $x^j_l$，我们有 $P_lx^j_l = \mathbf{0}$。在实际训练中，当学习任务的数量增加，特征矩阵 $A_l$ 将变为满秩，然后，对于 (5)，没有非零解 $P_l$。 当 $\alpha$ 变大时，解 $P_l$ 将更加关注 $\{x_l^j, j=1,2,...\}$ 中最重要的方向，而忽略 $\{x_l^j\}$ 中的噪声。 少数占据非主流方向的异常值会减少可用于新任务的内存空间。 从理论上讲，减小 $\alpha$ 值会提高生成图像的质量，这也与实验结果一致。

为了解决上述优化问题，我们计算目标函数对 $P$ 的导数，得到

$$
\tag{6}
2A_lA_l^{\intercal}P+2\alpha (P-\mathbf{I})=\mathbf{0}
$$

然后，我们得到公式（5）的解，即

$$
\tag{7}
P_l=\alpha(A_lA_l^{\intercal}+\alpha\mathbf{I})^{-1}
$$

我们应用 RLS 算法递归计算 $P_l$。 最后，我们得到 $P_l$ 的迭代公式，即

$$
\tag{8}
P_l(k+1)=P_l(k)-\frac{P_l(k)x_l^{k+1}x_l^{k+1\intercal}P_l(k)}{\alpha+x_l^{k+1\intercal}P_l(k)x_l^{k+1}}
$$

论文作者总结了算法 1 中提出的 GopGAN。在所有任务学习之前，将每一层中的正交投影矩阵 $P_l$ 初始化为单位矩阵 $\mathbf{I}$。需要注意的是，梯度正交投影仅在新任务完成后更新学习。 从理论上讲，投影算子的秩 $Rank(P)$ 表示未学习任务的可用内存空间。 当 $Rank(P)=0$ 时，权重不会更新，这意味着网络失去了学习新任务的能力。

### GAN 的任务相关潜在向量

在传统的 CGAN 中，除了标签条件 $c^j$ 之外，所有类别共享相同的潜在向量 $z^j$。 潜在向量是从标准正态分布中采样的，即 $z_k^j \sim N(0,1)$，其中 $z^j = [z^j_1, z^j_2,..., z^j_k ,...,z^j_{d_{1}}]$。如果我们忽略标签条件，则生成器第一层的输入 $x^j_1$ 等于长度为 $d_1$ 的 $z^j$。 $x^j_1$ 的关系矩阵的数学期望是 $\mathbb{E}[x^{j\intercal}_1x^j_1]=d_1$。 根据更新方程 (8)，考虑生成器的第一层 ($l = 1$)，我们假设公式 (8) 在忽略 $\alpha$ 时仍然近似成立，因为 $\alpha$ 的值非常小，然后，我们有

$$
\tag{9}
\begin{aligned}
\mathbb{E}[P_1(k+1)] &\approx \mathbb{E}[P_1(k)]-\frac{\mathbb{E}[P_l(k)]\mathbb{E}[x_l^{k+1}x_l^{k+1\intercal}]\mathbb{E}[P_l(k)]}{\mathbb{E}[x_l^{k+1\intercal}P_l(k)x_l^{k+1}]} \\
                     &\approx \mathbb{E}[P_1(k)]-\frac{\mathbb{E}[P_l(k)]}{d_1} \\
                     &=(1-\frac{1}{d_1})^{k+1}\mathbb{E}[P_1(0)] \\
                     &=(1-\frac{1}{d_1})^{k+1}\mathbf{I}
\end{aligned}
$$

在 GopGAN 的训练中，潜在向量的长度通常设置为 100，$P_1$ 的更新步数超过 1000，这将导致 $P_l = \mathbf{0}$。如果矩阵 $P_l$ 在学习一个任务后变成零矩阵，那么当 GopGAN 开始训练一个新任务时，第一层的权重将不再更新，这不仅严重阻碍了网络训练，而且降低了生成图像的质量。即使有标签条件 $c^j$ (即 $x^j_1=z^j\oplus c^j$)，由于标签条件 $c^j$ 是 one-hot 向量，未学习任务的有效内存空间只是其自身标签索引中的一维，仍然对网络的训练造成很大干扰。

为了扩展未学习任务的可用内存空间，论文作者提出了一种任务相关的潜在向量构造方法。 潜在向量被划分为 $M$ 个切片，切片的数量等于任务的数量。 任务 $T_i$ 的潜在子向量表示为 $z^j_i$，长度为$n_i$。 在训练带有标签 $i$ 的任务 $T_i$ 时，切片 $z^j_i$ 被激活，而其他任务的切片将被停用，这可以为未学习的任务提供足够的内存空间。 在本文中，论文作者采用 one-hot 形式来构造潜在向量，类似于标签条件 $c^j$ 的构造，其中去激活的潜在子向量被零向量替换。 训练任务 $T_i$ 时，条件隐向量为

$$
\tag{10}
z^j=[\mathbf{0}^{\intercal}_1,...,\mathbf{0}^{\intercal}_{i-1},z^j_i,\mathbf{0}^{\intercal}_{i+1},...,\mathbf{0}^{\intercal}_{M}]
$$

使用依赖于任务的潜在向量，第一层中未学习任务的可用内存空间将从 0 增加到 $d_1-\sum_{i=1}^Q n_i$，其中 $Q$ 表示学习任务的数量。

## 讨论

在本节中，论文作者将讨论提出的方法 GopGAN 与其他方法之间的关系，包括 SFT、EWC、OWM 和 LifelongGAN 。

### GopGAN 和 SFT 的关系

对于 SFT，当它的生成器开始学习一个新任务 $T_i$ 时，它的权重使用在最后一个任务 $T_{i-1}$ 之后学习的权重进行初始化，并且第 $l$ 层的权重 $W^{SFT}_{l,i}(t)$ 在步骤 $t$ 更新

$$
\tag{11}
W^{SFT}_{l,i}(t) = W^{SFT}_{l,i}(t-1) -\lambda_i \Delta W_{l,i}(t)
$$
其中 $\Delta W_{l,i}(t)$ 表示相应的梯度。 与 SFT 不同，GopGAN 在步骤 $t$ 更新权重 $W^{Gop}_{l,i}(t)$为

$$
\tag{12}
W^{Gop}_{l,i}(t) = W^{Gop}_{l,i}(t-1) -\lambda_i P^{\intercal}_l\Delta W_{l,i}(t)
$$
其中梯度 $\Delta W_{l,i}(t)$ 由矩阵 $P_l$ 修改，该矩阵是通过寻求最优解获得的，即

$$
\tag{13}
P_l=\arg \underset{P}{\min} (||PA_l||_{F}^2+\alpha ||P-\mathbf{I}||_{F}^2)
$$
其中矩阵 $A_{l}=[x_{l}^{1}, x_{l}^{2},..., x_{l}^{N_{i-1}}]$ 是通过在第 $l$ 层收集所有学习任务的输入来构造的，$x^k_l$ 表示来自任务 $T_1, T_2, ... , T_{i-1}$的第 $k$ 个示例的第 $l$ 层的输入。

在实践中，在训练新任务时生成器收敛之前，梯度 $\Delta W_{l,i}$ 通常不是零矩阵，即 $\Delta W_{l,i}(t) \neq \mathbf{0}$，所以只有当 $P_l = \mathbf{I}$ 时，公式 (11) 等于 公式 (12)。 对于正实数 $\alpha$ 和 $A_l \neq \mathbf{0}$，当 $\alpha$ 接近正无穷大时，$P_l$ 的极限值由下式获得

$$
\tag{14}
\begin{aligned}
\underset{\alpha \rightarrow +\infty}{\lim} P_l &= \underset{\alpha \rightarrow +\infty}{\lim} \arg \underset{P}{\min} (||PA_l||_{F}^2+\alpha ||P-\mathbf{I}||_{F}^2) \\
                                                                           &= \underset{\alpha \rightarrow +\infty}{\lim} \arg \underset{P}{\min} (\alpha ||P-\mathbf{I}||_{F}^2)  \\                                   
                                                                           &= \mathbf{I}
\end{aligned}
$$
上述推导表明，当 $\alpha$ 接近正无穷大时，SFT 是 GopGAN 的一个特例。 对于 GopGAN 方法，随着 $\alpha$ 变大，生成器会忘记越来越多从先前任务中学到的旧知识，最终退化为 SFT。 论文作者的实验还表明，较小的 $\alpha$ 值可以帮助生成器保留更多的旧知识。

### GopGAN 和 EWC 的关系

在具有 EWC 的 GAN 中，生成器的损失可以表示为

$$
\tag{15}
L_{EWC} = L_{adv}+\frac{\lambda_{EWC}}{2}L_{ewc}
$$
其中 $L_{adv}$ 是 GAN 中常见的对抗性损失，$L_{ewc}$ 定义为

$$
\tag{16}
L_{ewc} = \sum _{l=1}^L \sum _{j=1} F_l^j(W_{l,i}^j-W_{l,i-1}^j)^2
$$

其中 $F_l^j$ 是第 $l$ 层的 Fisher 信息矩阵 $F_l$ 的第 $j$ 个对角元素，$W_{l,i}^j$ 是矩阵 $W_{l,i}$ 中的第 $j$ 个元素。 EWC的总损失由两部分组成：新任务生成损失 $L_{adv}$ 和新任务与旧任务之间的 EWC 损失 $L_{ewc}$。 $L_{adv}$ 使模型能够学习新任务，而 $L_{ewc}$ 则希望新模型能够尽可能地保留从旧任务中学到的知识。 总损失是新任务和旧任务之间的权衡。

公式 (15) 中总损失的第 $l$ 层中权重的梯度 $\Delta W_{l,i} = \partial L_{EWC}/ \partial W_{l,i}$ 也由两部分组成

$$
\tag{17}
\begin{aligned}
\Delta W_{l,i} &= \Delta W_{l,i}^{adv}+\frac{\lambda_{EWC}}{2}\Delta W_{l,i}^{ewc} \\
                      &=\frac{\partial L_{adv}}{\partial W_{l,i}} + \frac{\lambda_{EWC}}{2}\frac{\partial L_{ewc}}{\partial W_{l,i}}
\end{aligned}
$$

对于旧任务的输入 $A_{l,k}\;(k = 1, . . . , i - 1)$，权重 $W_{l,i}$ 基于 $\Delta W_{l,i}^{ewc}$ ($W_{l,i}^{ewc} = W_{l,i}-\lambda_i\Delta W_{l,i}^{ewc}$) 的更新， 尽量不忘记旧任务，即 $W_{l,i}^{ewc\intercal}A_{l,k} \approx W_{l,i-1}^{\intercal}A_{l,k}$ ($k = 1,...,i-1$)。然而，梯度 $\Delta W_{l,i}^{adv}$ 没有这个约束。 它不能保证根据 $\Delta W_{l,i}^{adv}$ 更新 $W_{l,i}$ 后，即 $W_{l,i}^{adv} = W_{l,i}-\lambda_i\Delta W_{l,i}^{adv}$，$W_{l,i}^{adv\intercal}A_{l,k} \approx W_{l,i-1}^{\intercal}A_{l,k}$ ($k = 1,...,i-1$)。因为损失 $L_{adv}$ 与旧任务完全无关，最大概率 $W_{l,i}^{adv\intercal}A_{l,k} \neq W_{l,i-1}^{\intercal}A_{l,k}$ ($k = 1,...,i-1$)。换句话说，新任务破坏了模型对旧任务的了解，这就是为什么总损失是新任务和旧任务之间的权衡。

EWC 还有一个问题。 对于 CNN，它有很多层。 在每一层中，新任务模型的权重在 $k = 1,...,i-1$, 时响应 $A_{l,k}$ 有一个小的波动。随着网络的前向传播，这些波动很可能在经过 ReLu 和 MaxPooling 等各种非线性运算后被大大放大，使得新模型对旧任务的响应几乎与之前模型中的原始响应相差甚远 . 这也是为什么 EWC 有时在持续学习中表现不佳的原因，尤其是在网络层数多的模型或任务量大的任务中。

应该注意的是，GopGAN 能够通过梯度正交投影保持对从 $T_1$ 到 $T_{i-1}$ 的所有先前任务的响应不变。 对于 GopGAN，我们有 $W_{l,i}^{\intercal}A_{l,k} = W_{l,i-1}^{\intercal}A_{l,k}$ ($k = 1,...,i-1$)，详细推导已在本文中给出。 值得注意的是，在 GopGAN 中，总损失的梯度由正交投影矩阵 $P$ 而不是部分梯度进行修改，这使得更新模型对旧任务的响应保持不变。 然而，EWC 仅体现在部分损失 EWC 中保持模型对旧任务的响应不变的目标，但新任务的对抗性损失仍然会破坏这种关系。

### GopGAN 和 OWM 的关系

OWM 和 GopGAN 方法分别被提出来服务于相同的目的，即通过沿着与学习任务的输入所跨越的空间正交的方向训练网络来解决灾难性遗忘问题。 比较而言，OWM 方法用于分类任务，GopGAN 方法用于 GAN 进行持续学习。 与 OWM 相比，论文作者的 GopGAN 有三个主要改进。

首先，在 OWM 的论文中，直接给出了矩阵 $P_{owm}$，没有任何推导来解释为什么该矩阵应该表示如下：

$$
\tag{18}
P_{owm}=\mathbf{I}-A(A^{\intercal}A+\alpha\mathbf{I})^{-1}A^{\intercal}
$$

在第 3.2 节中，论文作者给出了一个严格的数学证明来显示在特征空间的正交子空间中更新权重可以保证新任务的学习不会导致忘记在旧任务中获得的知识。 然后，通过定义和求解一个优化问题，论文作者推导出一个新的投影矩阵的最优解，记为 $P_{gop}$，即：

$$
\tag{19}
P_{gop} = \alpha (A^{\intercal}A+\alpha\mathbf{I})^{-1}
$$

根据 Woodbury 矩阵恒等式，可以推导出

$$
\tag{20}
\begin{aligned}
P_{gop} &= \alpha (A^{\intercal}A+\alpha\mathbf{I})^{-1} \\
             &=\mathbf{I}-A(A^{\intercal}A+\alpha\mathbf{I})^{-1}A^{\intercal} \\
             &= P_{owm}
\end{aligned}
$$

这表明论文作者的梯度正交投影矩阵等价于 OWM 中的矩阵。

其次，公式 (19) 的表达式便于应用 RLS 算法。 论文作者还在公式 (19) 中提供了如何递归计算 $P_{gop}$ 的详细推导，以便在学习新任务时无需存储用于学习先前任务的训练示例的特征。

第三，在 GAN 的持续学习中，论文作者发现生成器的噪声输入来自相同的分布并且被所有类别共享，这使得计算的投影矩阵接近于零矩阵，其证明见第 3.2节中的补充证明，然后，很少有内存空间可用于新任务。 为了解决这个问题，论文作者提出了一个新的任务相关的潜在向量，使每个任务具有不同的潜在向量，从而为新任务获得足够的内存空间。 大量实验表明，与仅基于 OWM 的 GAN 相比，使用依赖于任务的潜在向量，GAN 可以生成更好的图像质量。

### GopGAN 和 Lifelong GAN 的关系

论文作者定义 $A$ 表示学习任务的输入，$B$ 表示将由网络学习的第 $i$ 个任务的输入。 在训练第 $i$ 个任务期间，生成器是 $G_i$，前 $i-1$ 个任务的生成器是 $G_{i-1}$。

为了避免灾难性遗忘，论文作者的方法 GopGAN 在学习新任务时保持新生成器 $G_i$ 对学习任务数据 $A$ 的响应不变，即

$$
\tag{21}
\begin{aligned}
\mathrm{GopGAN}:\left\{\begin{matrix}
G_i(A)=G_{i-1}(A) = GT(A)\\ 
G_i(B)=GT(B)
\end{matrix}\right.
\end{aligned}
$$

其中 $GT(A)$ 表示输入 $A$ 的 ground truth，$G_i(B)=GT(B)$ 表示生成器 $G_i$ 可以生成与 ground truth 一致的真实图像。 $G_i(A)=G_{i-1}(A)$ 意味着 GopGAN 可以保持学习到的知识不变。 更严格地说，在 GopGAN 中，新网络中每一层对学习任务特征的响应也保持不变，而不仅仅是最终输出。

LifelongGAN 使用蒸馏损失来避免忘记学到的知识，可以用以下公式表示：

$$
\tag{22}
\begin{aligned}
\mathrm{LifelongGAN}:\left\{\begin{matrix}
G_i(B)=G_{i-1}(B)\\ 
G_i(B^{\mathrm{aux}})=G_{i-1}(B^{\mathrm{aux}})\\
G_i(B)=GT(B)
\end{matrix}\right.
\end{aligned}
$$

其中 $B^{\mathrm{aux}}$ 是 LifelongGAN 中通过蒙太奇 (montage) 或交换操作从训练数据 $B$ 生成的辅助数据。 LifelongGAN 试图通过提取生成器 $G_{i-1}$ 对新任务数据 $B$ 和 $B^{\mathrm{aux}}$ 的响应来保留学习任务的知识。因为之前的生成器$G_{i-1}$ 还没有接触到新任务的数据，所以将之前的生成器的知识提炼到新的任务上并不能让新的生成器 $G_{i-1}$ 完全保留已经学习到的知识。由于学习任务的数据 $A$ 和待学习任务的数据 $B$ 的分布不同，$G_i(B)=G_{i-1}(B)$ 和 $G_i(B^{\mathrm{aux}})=G_{i-1}(B^{\mathrm{aux}})$ 不等价于 $G_i(A)=G_{i-1}(A)$。而且，在训练新任务时，LifelongGAN 对学习任务的知识会受到新任务的干扰，这意味着对新任务的学习也会伴随着遗忘。论文作者的方法很好地克服了这个问题。
